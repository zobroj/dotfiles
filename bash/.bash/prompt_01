#!/bin/bash

set_prompt () {
	local last_cmd=$? # first line of fuction
	local txtreset='$(tput sgr0)'
	local txtbold='$(tput bold)'
	local txtblack='$(tput setaf 0)'
	local txtred='$(tput setaf 1)'
	local txtgreen='$(tput setaf 2)'
	local txtyellow='$(tput setaf 3)'
	local txtblue='$(tput setaf 4)'
	local txtpurple='$(tput setaf 5)'
	local txtcyan='$(tput setaf 6)'
	local txtwhite='$(tput setaf 7)'
	local fancyx='\342\234\227'	# unicode "✗"
	local checkmark='\342\234\223'	# unicode "✓"
	local COLOR_BAD=$txtred
	local COLOR_NEUTRAL=$txtwhite

	function git_status () {
		local unmerged_color=$txtpurple
		local unstaged_color=$txtred
		local staged_color=$txtcyan
		local clean_color=$txtblue

		local GIT_BRANCH=$(git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
		local GIT_COLOR
		local GIT_STATUS=$(git status 2> /dev/null)

		# Define Color
		status_contains () { echo "$GIT_STATUS" | grep -q "$1" ; }

		if status_contains "Unmerged paths:" ; then
			GIT_COLOR="$unmerged_color"
		elif status_contains "Changes not staged for commit:" ; then
			GIT_COLOR="$unstaged_color"
		elif status_contains "Changes to be committed:" ; then
			GIT_COLOR="$staged_color"
		else
			GIT_COLOR="$clean_color"
		fi

		# Only show if in a git repo
		[ $GIT_BRANCH ] && PS1+="\[$GIT_COLOR\]($GIT_BRANCH) "
	}

	# Newline
	PS1="\n"

	# Return Status: hidden if good
	if [[ $last_cmd != 0 ]]; then
	  PS1+="\[$COLOR_BAD\]$last_cmd "
	fi

	git_status

	# Current Path: Elucidate if home
	if [[ $(pwd) == $HOME ]]; then
	   PS1+="\[$COLOR_NEUTRAL\]\h$HOME/\w"
	else
	   PS1+="\[$COLOR_NEUTRAL\]\w"
	fi

	# Newline
	PS1+="\n"

	# User@Host: Hide if in tmux
	if [ -z $TMUX ]; then
	   PS1+="\u\[$txtwhite\]@\h "
	fi

	# Prompt: Red # for root, white $
	if [[ $EUID == 0 ]]; then
	   PS1+="\[$COLOR_BAD\]"
	else
	   PS1+="\[$COLOR_NEUTRAL\]"   
	fi
	PS1+="\\$ \[$txtreset\]"

	# Full date + full time (24h)
	#PS1+="\[$txtwhite\]\n\D{%A %d %B %Y %H:%M:%S}\n"
}
PROMPT_COMMAND='set_prompt'
